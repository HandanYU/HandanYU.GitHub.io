---
layout: post
title: MySQL基础    
summary: 本章讲述了MySQL的基础知识
featured-img: machine learning
language: chinese
category: MySQL
---

## 登录mysql语句

```
/usr/local/mysql/bin/mysql -u root -p
```

## 一、数据库系统

### 1、数据库系统的组成

数据库系统(DBS):通常由硬件、软件(操作系统、宿主语言、实用程序以及数据库管理系统)、数据库和用户组成，管理的对象是数据。

### 2、数据库系统的体系结构

```
集中式
C/S结构
B/S结构
分布式结构
```

## 二、关系数据库理论

### 1、实体相关概念

实体

属性

主键:能够唯一标识实体的属性为该实体的主键。比如学号式学生这个实体的主键，因为可以通过学号唯一确定一个学生。

实体型：学生是一个实体型

实体集：全体学生是一个实体集

联系：教师实体与学生实体之间存在着教与学的联系

### 2、数据模型三要素

```
 数据结构
 数据操作
 完整性约束
```

### 3、关系运算

```
 选择
 投影
 连接
```

 #### 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。

 - IS NULL: 当列的值是 NULL,此运算符返回 true。
- IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。
- <=>: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。

## 三、DDL(data definition language)

用来定义数据库中的对象，其中对象包括库、表、列等

### 1、数据类型

double(a,b):表示整数和小数最多一共占a位，其中小数位必须为b位。

### 2、基本操作(增，删，查，改)

```
show databases;
create database 库名;
use (库名);  当需要编辑库内表的信息的时候，需要先进入到该库
```

```
create table (表的名称)(
列名1 数据类型(位数),
列名2 数据类型(位数),
列名n 数据类型(位数)   
注意:最后一行没有逗号
);
mysql> create table if not exists student
    -> (
    -> name char(8) not null comment'姓名',
    -> num char(11) not null comment'学号',
    -> birthday date not null comment'出生日期',                
    -> primary key (num)                
    -> );                               
    
    Query OK, 0 rows affected (0.03 sec)
```

describe student; 查看student这个表的基本结构

```
mysql> describe student;
+----------+----------+------+-----+---------+-------+
| Field    | Type     | Null | Key | Default | Extra |
+----------+----------+------+-----+---------+-------+
| name     | char(8)  | NO   |     | NULL    |       |
| num      | char(11) | NO   | PRI | NULL    |       |
| birthday | date     | NO   |     | NULL    |       |
+----------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

insert into 表的名称 values
(,,...),(,,...);向表中插入多行数据

```
mysql> insert into student values
    -> ('e',3,'1999-02-09'),
    -> ('r',4,'1999-02-08');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

replace into 表的名称 values (,,...),(,,...); 向表中插入多行数据

```
mysql> replace into student values
    -> ('q',1,'1999-01-01'),
    -> ('w',2,'1999-01-02');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select * from student;
+------+-----+------------+
| name | num | birthday   |
+------+-----+------------+
| q    | 1   | 1999-01-01 |
| y    | 12  | 1999-01-06 |
| w    | 2   | 1999-01-02 |
| w    | 23  | 1998-01-09 |
+------+-----+------------+
4 rows in set (0.00 sec)
```

select * from 表的名称；输出表的记录

```
mysql> select * from student;
+------+-----+------------+
| name | num | birthday   |
+------+-----+------------+
| y    | 12  | 1999-01-06 |
| w    | 23  | 1998-01-09 |
+------+-----+------------+
2 rows in set (0.00 sec)
```

```
create show table (表的名称); 查看制定表的创建语句
drop table (表的名称); 
drop database (库的名称);
alter talbe (表的名称) add (新增列的名称 数据类型(位数));
```

利用load data 语句将数据装入数据库表中
其中在txt文档中需要用tab符来将没有字符段隔开，

```
load data local infile "文件地址" into table 表名称;
```


### 3、系统变量

##### 1）全局变量

在Mysql启动时由服务器自动将它们初始化为默认值，对全局变量对修改会影响到整个服务器。

##### 2）会话变量

每次建立一个新的连接时，由Mysql来初始化。随时定义和使用，会话结束就释放。定义会话变量的时候要在前面加上一个@符号

##### 3) 局部变量

- 局部变量必须定义在函数、触发器、存储过程等存储程序中。
- 局部变量的作用范围仅仅局限于存储程序中
- 局部变量必须先定义（运用declare），才可以使用set命令活着select语句为其赋值。局部变量的定义在begin...end语句块之间。
- 局部变量作为存储过程或者函数的参数使用。此时虽然不需要使用declare命令定义，但需要参数的数据类型
- 局部变量也可以直接嵌入到select,insert,update,delete语句的条件表达式中。

定义局部变量myage，数据类型为int,默认值为20.

```
declare myage int default 20;
```

将局部变量myage赋值为18

```
set myage=18;
```

###### 读取PI的值：

```
mysql> select PI();
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
1 row in set (0.01 sec)
```

定义一个会话变量\
:=语句只能用来赋值，=语句只有在set和update语句中用来赋值，在select语句中是用作比较

**运用set来赋值**

```
set @var:=1;  
select @var; 
**结果为1**
set @var=1;
select @var;  
**结果为1**
```

**运用select来赋值**

```
select @var:=@var+1;
select @var;  
**结果为2**
select @var=@var+1;
**结果为0**
```

**大多数的系统变量应用于其他SQL语句时候，必须在名称前加@@**

```
select @@version,current_date;
```

**查找字符以a开头的系统变量**

```
show variables like 'a%';
```

**修改系统变量的值**  不是所有的系统变量值都可以修改

```
set @@session.sql_select_limit=100;
```

### 4、运算符和表达式

##### 1）比较运算符

判断是否相等是用“=”，而不是“==”。

###### 判断是否在区间内

```
set @a=2;
select @a between 1 and 14;
```

###### 判断是否是这种模式的

```
set @q='qew';
select @q like 'q%';//%表示一串字符 *结果为1*
select @q like 'q_';//_表示一个字符 *结果为0*
```

##### 查找该字符是否以指定字符开头

```
set @q='qwerty';
select @q regexp '^q';
```

##### 查找该字符是否以指定字符结尾

```
set @q='qwerty';
select @q regexp 'y$';
```

##### 查找该字符中间是否存在指定字符串

```
set @q='qwerty';
select @q='.wer';
```

##### 2）逻辑运算符

###### && and  与

###### || or   或

###### !  not  非

###### xor 异或（不一样为真）

### 5、字符串函数

###### char_length 计算字符串长度

```
mysql> set @r='qwertyu';
Query OK, 0 rows affected (0.00 sec)
mysql> select char_length(@r);
+-----------------+
| char_length(@r) |
+-----------------+
|               7 |
+-----------------+
1 row in set (0.00 sec)
```

###### left 返回从字符串最左边开始指定个数的字符串

```
mysql> select left(@r,3);
+------------+
| left(@r,3) |
+------------+
| qwe        |
+------------+
1 row in set (0.01 sec)
```

###### concat 返回连接参数产生的字符串

```
mysql> select concat('my','sq','34');
+------------------------+
| concat('my','sq','34') |
+------------------------+
| mysq34                 |
+------------------------+
1 row in set (0.00 sec)
```

```
mysql> select concat('my','sq',null);
+------------------------+
| concat('my','sq',null) |
+------------------------+
| NULL                   |
+------------------------+
1 row in set (0.00 sec)
```

###### substring 截取一段字符串

```
mysql> select substring('wetqhhhs',2,5);
+---------------------------+
| substring('wetqhhhs',2,5) |
+---------------------------+
| etqhh                     |
+---------------------------+
1 row in set (0.00 sec)
```

###### reverse 反转字符串

```
mysql> select reverse('abcd');
+-----------------+
| reverse('abcd') |
+-----------------+
| dcba            |
+-----------------+
1 row in set (0.00 sec)
```

### 6、日期和时间函数

###### curdate 获取当前系统的日期

```
mysql> select curdate();
+------------+
| curdate()  |
+------------+
| 2019-03-09 |
+------------+
1 row in set (0.00 sec)
```

###### curtime 获取当前系统的时间

```
mysql> select curtime();
+-----------+
| curtime() |
+-----------+
| 21:42:31  |
+-----------+
1 row in set (0.00 sec)
```

###### date_add/date_sub 日期时间相加减

```
mysql> select date_add(curdate(),interval 34 day);
+-------------------------------------+
| date_add(curdate(),interval 34 day) |
+-------------------------------------+
| 2019-04-12                          |
+-------------------------------------+
1 row in set (0.00 sec)
```

###### datediff 计算距离当天还有多少天

```
mysql> select datediff(now(),'2022-01-06');
+------------------------------+
| datediff(now(),'2022-01-06') |
+------------------------------+
|                        -1034 |
+------------------------------+
1 row in set (0.00 sec)
```

###### 日期/时间格式化

```
mysql> select date_format(now(),'%W %d %m %Y,%r %p');
+----------------------------------------+
| date_format(now(),'%W %d %m %Y,%r %p') |
+----------------------------------------+
| Saturday 09 03 2019,09:50:45 PM PM     |
+----------------------------------------+
1 row in set (0.00 sec)
```

**格式化函数**

```
mysql> select format(1/3,2);
+---------------+
| format(1/3,2) |
+---------------+
| 0.33          |
+---------------+
1 row in set (0.00 sec)
```
## 四、DML(data manipulation language)

用来定义数据库记录（数据）

## 五、创建数据库表

表决定了数据库的结构，表是存放数据的地方

**注意**
auto_increment 表示当值为null的时候，会自动根据前面的数字自加。

## student 

```
mysql> create table student
    -> (
    -> student_num int(20) auto_increment,
    -> student_id char(20) not null,
    -> student_name char(20) not null,
    -> student_sex enum('F','M') default'F',
    -> primary key(student_num)
    -> );
```

## course

```
mysql> create table course
    -> (
    -> course_num int(20) auto_increment,
    -> course_name char(20) not null,
    -> primary key(course_num)
    -> );
```

## grade

#### (用来连接表student & course)

```
mysql> create table grade
    -> (
    -> grade_num int(20) auto_increment,
    -> student_num int(20) not null,
    -> course_num int(20) not null,
    -> primary key(grade_num)       
    -> );
```

## teacher

```
mysql> create table teacher
    -> (
    -> teacher_num int(20) auto_increment,
    -> teacher_name char(20) not null,
    -> teacher_position char(20) not null,
    ->  teacher_major char(20) not null,
    -> teacher_faculty char(20) not null,
    ->  primary key(teacher_num)
    -> );
Query OK, 0 rows affected (0.01 sec)
```

### 插入内容

```
mysql> insert into student values   
    -> (1,'1','a','F'),
    -> (2,'2','b','F'),
    -> (3,'3','c','M');
    -> (null,'4','d','F');
```

```
mysql> insert into course values
    -> (1,'aa'),
    -> (2,'bb'),
    -> (3,'cc');
```

```
mysql> insert into grade values
    -> (1,1,2),
    -> (2,3,1),
    -> (3,2,3);
```

需要将学生及其对应的课程名对应输出

```
mysql> select course_num,student.student_name
    ->  from grade join student on grade.student_num=student.student_num;
```

```
+------------+--------------+
| course_num | student_name |
+------------+--------------+
|          2 | a            |
|          3 | b            |
|          1 | c            |
|          1 | d            |
+------------+--------------+
```

## 增添字符段

```
mysql> alter table student 
    -> add student_birthday char(20) not null after student_sex;
```

在新增段字符段中填内容，根据条件student_num=1,也就是在第一组信息中的新增字符段中填入相应内容。

```
mysql> update student set student_birthday='1999-01-06' where student_num=1;
```

## 通过条件限制查询表内容

* where子句 ：条件可以有多个用 and /or 连接

```
mysql> select *from course where course.course_num in (3,5,7) and course.course_testtime=0;
+------------+-------------+---------------+-----------------+-------------+
| course_num | course_kind | course_period | course_testtime | course_name |
+------------+-------------+---------------+-----------------+-------------+
|          3 | 数学类      |            48 |               0 | 微积分      |
+------------+-------------+---------------+-----------------+-------------+
1 row in set (0.00 sec)
```

* where...in 可以用来查询不连续的行

```
mysql> select *from course where course.course_num in (3,5,7);
+------------+--------------------+---------------+-----------------+--------------+
| course_num | course_kind        | course_period | course_testtime | course_name  |
+------------+--------------------+---------------+-----------------+--------------+
|          3 | 数学类             |            48 |               0 | 微积分       |
|          5 | 计算机工科类       |            16 |              16 | 电子技术     |
|          7 | 计算机类           |            32 |              16 | 数据结构     |
+------------+--------------------+---------------+-----------------+--------------+
3 rows in set (0.00 sec)
```

* where...not in 可以用来查询不在该范围内的

```
mysql> select *from course where course.course_num not in (1,3,5,7,9,11,2,10);
+------------+--------------------+---------------+-----------------+--------------+
| course_num | course_kind        | course_period | course_testtime | course_name  |
+------------+--------------------+---------------+-----------------+--------------+
|          4 | 计算机类           |            32 |              16 | 计算方法     |
|          6 | 计算机类           |            32 |              16 | C语言        |
|          8 | 计算机工科类       |            16 |              16 | 软件工程     |
+------------+--------------------+---------------+-----------------+--------------+
3 rows in set (0.00 sec)
```

* between and 的范围查询，查询连续行内容

```
mysql> select *from course where course.course_num between 4 and 6;
+------------+--------------------+---------------+-----------------+--------------+
| course_num | course_kind        | course_period | course_testtime | course_name  |
+------------+--------------------+---------------+-----------------+--------------+
|          4 | 计算机类           |            32 |              16 | 计算方法     |
|          5 | 计算机工科类       |            16 |              16 | 电子技术     |
|          6 | 计算机类           |            32 |              16 | C语言        |
+------------+--------------------+---------------+-----------------+--------------+
3 rows in set (0.00 sec)
```

```
update table_name set field1+
```

- 运用带 like 字符匹配查询

  - “%” 可以匹配一个或多个字符，可以代表任意长度的字符串，长度可以为0。
  - “_” 只匹配一个字符。

```
mysql> select student.student_name from student where student.student_name like '我%';
+--------------+
| student_name |
+--------------+
| 我热饭       |
| 我去玩       |
+--------------+
2 rows in set (0.00 sec)
```

```
mysql> select student.student_name from student where student.student_name like '_去_';
+--------------+
| student_name |
+--------------+
| 我去玩       |
+--------------+
1 row in set (0.00 sec)
```

* where...and(...or...)：and,or嵌套使用

```
mysql> select *from course where course_kind='计算机类' and (course_testtime=16 or course_period=16);
+------------+--------------+---------------+-----------------+-----------------+
| course_num | course_kind  | course_period | course_testtime | course_name     |
+------------+--------------+---------------+-----------------+-----------------+
|          1 | 计算机类     |            32 |              16 | 数据库原理      |
|          2 | 计算机类     |            16 |              16 | 云计算          |
|          4 | 计算机类     |            32 |              16 | 计算方法        |
|          6 | 计算机类     |            32 |              16 | C语言           |
|          7 | 计算机类     |            32 |              16 | 数据结构        |
+------------+--------------+---------------+-----------------+-----------------+
5 rows in set (0.00 sec)
```

## order by子句

- order by子句包含的列并不一定出现在选择列表中
- order by子句可以通过指定列名、函数值和表达式的值进行排序
- order by子句不可以使用text,ntext,image类型的列
- 在order by子句中可以同时指定多个排序项。
- 后面可以加上关键字desc来实现降序输出，升序asc是默认值

```
mysql> select student_name,begin_score from student order by begin_score desc;
+--------------+-------------+
| student_name | begin_score |
+--------------+-------------+
| 于晗但       | 98          |
| 我去玩       | 90          |
| 与哈维       | 89          |
| 我热饭       | 78          |
+--------------+-------------+
4 rows in set (0.00 sec)
```

## group by子句

- group by子句可以将查询结果按照属性列或者属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的聚合值。
- 在需返回聚合函数的时候，需要使用group by子句

### 使用 WITH ROLLUP

```
mysql> select reader_id,count(*) from borrow_info group by reader_id with rollup;
+-----------+----------+
| reader_id | count(*) |
+-----------+----------+
|         1 |        2 |
|         2 |        1 |
|         5 |        1 |
|      NULL |        4 |
+-----------+----------+
4 rows in set (0.00 sec)
```

### 使用 coalesce 来设置一个可以取代 NUll 的名称

```
mysql> select coalesce(reader_id,'总数'),count(*) from borrow_info group by reader_id with rollup;
+------------------------------+----------+
| coalesce(reader_id,'总数')   | count(*) |
+------------------------------+----------+
| 1                            |        2 |
| 2                            |        1 |
| 5                            |        1 |
| 总数                         |        4 |
+------------------------------+----------+
4 rows in set (0.00 sec)
```

## 用limit限制查询结果的数量

limit a,b;表示限制输出从第(a+1)条开始的b条信息


```
mysql> select student_id,student_name,student_sex from student limit 1,2;
+------------+--------------+-------------+
| student_id | student_name | student_sex |
+------------+--------------+-------------+
| 2          | 与哈维       | M           |
| 3          | 我热饭       | M           |
+------------+--------------+-------------+
2 rows in set (0.00 sec)
```

## 聚合函数查询

### count()函数

对于除‘*’意外的任何参数，返回所选择聚合中非null值的行的数目

```
mysql> select count(student_num) from grade group by student_num;
+--------------------+
| count(student_num) |
+--------------------+
|                  6 |
|                  4 |
|                  5 |
|                  4 |
+--------------------+
4 rows in set (0.00 sec)

mysql> create view cou as select count(student_num) from grade group by student_num;
Query OK, 0 rows affected (0.01 sec)

mysql> create view C as select count(student_num) as '数量'  from grade group by student_num;
Query OK, 0 rows affected (0.01 sec)

mysql> select count(数量) as 'num' from C;
+-----+
| num |
+-----+
|   4 |
+-----+
1 row in set (0.00 sec)
```

# 表的连接

## 内连接【inner join，也可以写成join】

select 表名1.字段名1，表名2.字段名2 from 表名1（2） inner join 表名2（1）on  条件 group by  。。;

```
mysql> select course.course_name,avg(grade.score) from course inner join grade on grade.course_num=course.course_num group by grade.course_num;
+-----------------+------------------+
| course_name     | avg(grade.score) |
+-----------------+------------------+
| 数据库原理      |          91.0000 |
| 云计算          |          98.0000 |
| 微积分          |          93.6667 |
| 计算方法        |          89.0000 |
| 电子技术        |          96.0000 |
| C语言           |          93.0000 |
| 数据结构        |          88.0000 |
| 软件工程        |          95.0000 |
| 经济学          |          87.5000 |
| 解剖学          |          89.3333 |
| 汉语言文学      |          90.0000 |
+-----------------+------------------+
11 rows in set (0.00 sec)
```

等价于运用where子句

```
mysql> select course.course_name,avg(grade.score) from course, grade where grade.course_num=course.course_num group by grade.course_num;
```

## 交叉连接

#### 一般不使用，而是要避免的现象，防止笛卡尔积出现（表1的行数*表2的行数）

* select 表名1.字段名1，表名2.字段名2 from 表名1(2) cross join  表名2(1);


* select 表名1.字段名1，表名2.字段名2 from 表名1(2),表名2(1);

## 左连接【left join】

#### 获取左表所有记录，即使右表没有对应匹配的记录，也就是最后获取的表的行数由左表决定

```
mysql> select  borrow_info.reader_id,borrow_info.book_id,book.book_author from borrow_info left join book on borrow_info.book_id=book.book_id;
+-----------+---------+-------------+
| reader_id | book_id | book_author |
+-----------+---------+-------------+
|         1 |       2 | 易中天      |
|         1 |      11 | 余华        |
|         2 |       3 | 周国平      |
|         5 |       1 | 梁晓声      |
+-----------+---------+-------------+
4 rows in set (0.00 sec)
```

## 右连接【right join】

#### 获取右表所有记录，即使左表没有对应匹配的记录,也就是最后获取的表的行数由右表决定

```
ysql> select  borrow_info.reader_id,borrow_info.book_id,book.book_author from borrow_info right join book on borrow_info.book_id=book.book_id;
+-----------+---------+---------------------+
| reader_id | book_id | book_author         |
+-----------+---------+---------------------+
|         1 |       2 | 易中天              |
|         1 |      11 | 余华                |
|         2 |       3 | 周国平              |
|         5 |       1 | 梁晓声              |
|      NULL |    NULL | 乔斯坦.贾德         |
|      NULL |    NULL | 余华                |
|      NULL |    NULL | 路遥                |
|      NULL |    NULL | 郭敬明              |
|      NULL |    NULL | 毕飞宇              |
|      NULL |    NULL | 东野圭吾            |
|      NULL |    NULL | 卡勒德.胡赛尼       |
+-----------+---------+---------------------+
11 rows in set (0.00 sec)
```

## 连接多个表

要求输出来自n个不同表的内容，则至少需要建立(n-1)个连接条件 
**注意：需要通过一个共同的表格去连接多个表，即写在from后面**

```
mysql> select student.student_name,course.course_name,grade.score                   
-> from grade join student on student.student_num=grade.student_num        
-> join course on course.course_num=grade.course_num
-> where grade.score>90;
+--------------+-----------------+-------+
| student_name | course_name     | score |
+--------------+-----------------+-------+
| 于晗但       | 云计算          |    98 |
| 我去玩       | 数据库原理      |    95 |
| 于晗但       | 微积分          |    98 |
| 于晗但       | 电子技术        |    96 |
| 与哈维       | C语言           |    93 |
| 与哈维       | 软件工程        |    95 |
| 与哈维       | 解剖学          |    91 |
| 我热饭       | 微积分          |    98 |
+--------------+-----------------+-------+
8 rows in set (0.00 sec)
```

## 合并多个结果集(uion)

注意合并的多个表中的字段名需要一致

* union：不重复输出相同的数据行

```
mysql> select student_num,student_name,student_sex from student where student_name like '于%' 
    -> union
    -> select student_num,student_name,student_sex from student where student_num<3;
+-------------+--------------+-------------+
| student_num | student_name | student_sex |
+-------------+--------------+-------------+
|           1 | 于晗但       | F           |
|           2 | 与哈维       | M           |
+-------------+--------------+-------------+
2 rows in set (0.00 sec)
```

* union all:输出重复的数据行

```
mysql>  select student_num,student_name,student_sex from student where student_name like '于%'
    -> union all
    -> select student_num,student_name,student_sex from student where student_num<3;
+-------------+--------------+-------------+
| student_num | student_name | student_sex |
+-------------+--------------+-------------+
|           1 | 于晗但       | F           |
|           1 | 于晗但       | F           |
|           2 | 与哈维       | M           |
+-------------+--------------+-------------+
3 rows in set (0.00 sec)
```

# 导入内容，先通过excel导出utf16，然后赋值到page中再导出txt.

# 每次重新创建一个数据库都需要修改数据库以及其中的字段的字符集。

## 查看字段的字符集

```
show full columns from teacher
```

## 修改字段的字符集

```
alter table course change old_course_name new_course_name char(20) character set utf8;
```

## 修改数据表employees的字符集

```
alter table employees character set utf8
```

## 修改数据库enterprises的字符集

```
alter database enterprises character set utf8
```

## 通过一个有关联的字段，提取出两张表中部分信息，并按照某个字段排序

```
select 字段1，字段2，字段3 from 表1，表2,表3 where 条件1 and 条件2 order by 字段名；
```

## 将一张表中的信息插入到另一张表中对应位置

```
mysql> insert into go(id,grr) select id,gr from g;
Query OK, 19 rows affected (0.00 sec)
Records: 19  Duplicates: 0  Warnings: 0

mysql> select *from go;
+------+------+
| id   | grr  |
+------+------+
|   98 | 1    |
|   99 | 2    |
|  100 | 3    |
|   87 | 4    |
|   80 | 5    |
|   90 | 6    |
|   96 | 7    |
|   87 | 8    |
|   80 | 9    |
|   95 | 10   |
|   98 | 11   |
|   94 | 12   |
|   93 | 13   |
|   83 | 14   |
|   88 | 15   |
|   91 | 16   |
|   90 | 17   |
|   78 | 18   |
|   80 | 19   |
+------+------+
19 rows in set (0.00 sec)
```

* 存在一个问题，当我不是在一张空表中为其中一空的列传入数据时候，总会自动新增行？

# 子查询

## 利用子查询生成派生表

利用子查询过滤出期末成绩高于90分，总评成绩高于90分的学生学号和课程号还有总评成绩。

```
mysql> select TT.student_num,TT.course_num, 
    -> TT.finalscore*0.8+TT.score*0.2 总评
    -> from (select * from grade where finalscore>90) as TT
    ->  where TT.finalscore*0.8+TT.score*0.2>90 order by 总评;
+-------------+------------+-------------------+
| student_num | course_num | 总评              |
+-------------+------------+-------------------+
|           1 |          8 |              93.2 |
|           4 |          6 |              93.4 |
|           2 |          3 | 93.80000000000001 |
|           1 |          2 | 94.80000000000001 |
|           1 |          1 | 94.80000000000001 |
|           3 |          4 | 94.80000000000001 |
|           3 |          5 | 95.60000000000001 |
|           3 |          1 |              98.2 |
|           1 |          7 |              98.2 |
|           2 |          3 |              98.4 |
|           3 |          4 |              99.2 |
+-------------+------------+-------------------+
11 rows in set (0.00 sec)
```

## 根据分组进行计算

计算出每位同学的期末平均分

```
mysql> select student_num,avg(finalscore) from grade group by student_num;
+-------------+-------------------+
| student_num | avg(finalscore)   |
+-------------+-------------------+
|           1 | 92.16666666666667 |
|           2 |             91.75 |
|           3 |              95.2 |
|           4 |                89 |
+-------------+-------------------+
4 rows in set (0.00 sec)
```

**比较查询**

查询期末成绩比选择该课程总平均期末成绩低的学生学号、课程号和期末成绩。

```
mysql> select student_num,course_num,finalscore from grade as a
    -> where finalscore<(select avg(finalscore) from grade as b
    -> where a.course_num=b.course_num group by course_num);
+-------------+------------+------------+
| student_num | course_num | finalscore |
+-------------+------------+------------+
|           4 |          1 | 89         |
|           2 |          5 | 89         |
|           3 |          3 | 86         |
|           4 |          7 | 89         |
|           3 |          4 | 96         |
|           4 |          3 | 84         |
|           2 |          1 | 86         |
+-------------+------------+------------+
7 rows in set (0.00 sec)
```

## 带in关键字的子查询

```
mysql> select student_num,student_name from student where student_num in (select student_num from grade where finalscore>97);
+-------------+--------------+
| student_num | student_name |
+-------------+--------------+
|           3 | 我热饭       |
|           2 | 与哈维       |
|           1 | 于晗但       |
+-------------+--------------+
3 rows in set (0.01 sec)
```

## 带exists关键字的子查询

## 创建视图

1、视图创建好之后是会被保存下来的，可以在创建的视图中进行检索\
2、如果与视图相关联的表或视图被删除，则该视图将不能再使用\
3、新创建的视图用来存放检索出来的结果

### 普通视图的创建

#### 在单表上创建视图

```
create view library_info as select *from reader;
```

#### 在多表上创建视图

保存多张表的数据

```
mysql> create view libraryinfo as select reader.reader_id,reader_name,borrow_date from borrow_info join reader on reader.reader_id=borrow_info.reader_id;
Query OK, 0 rows affected (0.02 sec)
```

#### 在已存在的视图上创建视图

```
mysql> create view info_library as select reader_name,borrow_date from libraryinfo;
Query OK, 0 rows affected (0.02 sec)
```

#### 通过修改视图来修改基本表的数据

视图若只依赖于一个基表，则可以直接通过视图来更新基本表的数据

```
mysql> create view mange as select *from manager;
Query OK, 0 rows affected (0.01 sec)

mysql> insert into mange values
    -> (6,'于晗丹','女',28,17857412488);
Query OK, 1 row affected (0.01 sec)
```

若一个视图依赖于多张基表，则一次只能修改一个基表的数据，不能同时修改多个基表的数据

```
mysql> select *from reader where reader_id<6;
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
| reader_id | reader_name | reader_sex | reader_age | reader_tel  | reader_max | reader_bnum | reader_available |
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
|         1 | 刘志增      | 男         |         19 | 17857312377 |          5 |           4 |                1 |
|         2 | 李昀陆      | 男         |         23 | 17857312376 |          5 |           5 |                0 |
|         3 | 赵彦博      | 女         |         18 | 17857312375 |          5 |           2 |                1 |
|         4 | 王奇        | 男         |         33 | 17857312374 |          5 |           1 |                1 |
|         5 | 刘炳金      | 男         |         19 | 17857312371 |          5 |           2 |                1 |
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
5 rows in set (0.00 sec)

mysql> create view libraryinfo as select reader.reader_id,reader_name,borrow_date from borrow_info join reader on reader.reader_id=borrow_info.reader_id;
Query OK, 0 rows affected (0.08 sec)
update libraryinfo set reader_name='于晗丹' where reader_id=5;
mysql> select *from reader where reader_id<6;
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
| reader_id | reader_name | reader_sex | reader_age | reader_tel  | reader_max | reader_bnum | reader_available |
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
|         1 | 刘志增      | 男         |         19 | 17857312377 |          5 |           4 |                1 |
|         2 | 李昀陆      | 男         |         23 | 17857312376 |          5 |           5 |                0 |
|         3 | 赵彦博      | 女         |         18 | 17857312375 |          5 |           2 |                1 |
|         4 | 王奇        | 男         |         33 | 17857312374 |          5 |           1 |                1 |
|         5 | 于晗丹      | 男         |         19 | 17857312371 |          5 |           2 |                1 |
+-----------+-------------+------------+------------+-------------+------------+-------------+------------------+
5 rows in set (0.00 sec)
```

但如果视图包含以下结构的任意一种，都不可以进行修改：

- 视图的列包含聚合函数
- 视图的列是通过表达式并使用列计算出其它列
- 含有distinct关键词
- 含有group by子句，order by子句，having子句
- 含有union运算符
- 视图的列位于选择列表中的子查询
- ==from子句中包含多个表==
- select语引用了不可更新视图
- ==where子句中的子查询，引用from子句中的表==

### 检查视图的创建

- 带有with check option语句即为创建检查视图
- 检查视图可以来检查是否有按条件进行对基表更新

### 定界符delimiter 和 begin...end语句块

#### 更改命令结束标记delimiter

因为mysql中默认的命令行结束符为";"，但是在创建函数或者存储过程中会有很多语句需要用“；”进行分割，因此需要修改命令行结束符\
**注意当修改完用完后，要及时该回";"**

```
mysql> delimiter /
mysql> select student_name from student where begin_score=89/
+--------------+
| student_name |
+--------------+
| 与哈维       |
+--------------+
1 row in set (0.01 sec)
```

#### begin...end 语句块

只能用于函数、存储过程、游标和触发器的定义内部

```
begin
     [局部]变量声明；
     程序代码行集；
end;
```

### 预处理语句

###### prepare语句，相当于定义一个函数；然后execute语句相当于调用函数执行语句。

mysql中的preapre,execute,deallocate统称为预处理语句

- prepare 语句用于预备一个语句，并赋予它名称area，借此在以后引用该语句。使用本语句中的"?"字符可以被用于制作参数。
- execute语句用于执行预处理语句，运用using子句列举用到的用户会话变量。
- deallocate prepare语句用于释放预处理语句。


#### 重要的说明

- 预处理语句中不能嵌套预处理语句
- 能够支持预处理操作的语句有：create table,delete,do,insert,replace,select,set,update和多数show语句.
- 预处理语句可以在已存储的过程中使用，但是不能在已存储的函数或者触发程序中使用.

在给定正方形的边长，计算正方形的面积

```
mysql> prepare area from 'select pow(?,2) as area_square';
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> set @a=10;
Query OK, 0 rows affected (0.00 sec)

mysql> execute area using @a;
+-------------+
| area_square |
+-------------+
|         100 |
+-------------+
1 row in set (0.00 sec)
mysql> deallocate prepare area;
Query OK, 0 rows affected (0.00 sec)
```

利用预处理语句先输出student中的前两行记录的部分数据，再输出student中的前三行记录的部分数据.

```
mysql> prepare STMT from "select *from student limit ?";
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> set @a=2;
Query OK, 0 rows affected (0.00 sec)

mysql> execute STMT using @a;
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
| student_num | student_id | student_name | student_sex | student_birthday | begin_score | student_tel | student_email |
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
|           1 | 1          | 于晗但       | F           | 1999/1/2         | 98 2 |      | 17857312377 | 123@126.com
|           2 | 2          | 与哈维       | M           | 1999-02-09       | 89          | 17857312376 | 124@126.com   |
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
2 rows in set (0.00 sec)

mysql> set @b=3;
Query OK, 0 rows affected (0.00 sec)

mysql> execute STMT using @b;
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
| student_num | student_id | student_name | student_sex | student_birthday | begin_score | student_tel | student_email |
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
|           1 | 1          | 于晗但       | F           | 1999/1/2         | 98 2 |      | 17857312377 | 123@126.com
|           2 | 2          | 与哈维       | M           | 1999-02-09       | 89          | 17857312376 | 124@126.com   |
|           3 | 3          | 我热饭       | M           | 1998-09-18       | 78          | 17857312375 | 125@126.com   |
+-------------+------------+--------------+-------------+------------------+-------------+-------------+---------------+
3 rows in set (0.00 sec)
```

## 自定义函数

```
注意(参数列表)需要写成:[参数名称 类型名]
delimiter //
create function [函数名](参数列表) returns [返回值类型]
begin
declare [变量名] [变量类型] default [初始值];
set 操作语句;
return ...;
end//
```

自定义一个计算长方形面积的函数并调用该函数

```
mysql> delimiter //
mysql> create function rectangle_area(long1 int,wide1 int) returns int 
    -> begin
    -> return long1 * wide1;
    -> end//
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> select rectangle_area(4,5);
+---------------------+
| rectangle_area(4,5) |
+---------------------+
|                  20 |
+---------------------+
1 row in set (0.00 sec)
```

### 函数的维护管理

#### 查看函数的定义

查看指定数据库中的所有自定义函数名

```
mysql> select name from MySQL.proc
    -> where db='teaching' and type='function';
+----------------+
| name           |
+----------------+
| area           |
| rectangle_area |
+----------------+
2 rows in set (0.00 sec)
```

查看指定函数名的详细信息

```
mysql> show create function area;
```

### MySQL的控制流语句

#### 条件控制语句

* if语句

#### 句式

```
if [condition] then [methods];
...
elseif [condition] then [methods];
elseif [condition] then [methods];
...
else [methods];
end if ;
```

#### 实例

```
mysql> delimiter //
mysql> create function exam_if(x int)returns int
    -> begin 
    -> if x=10 then set x=1;
    -> elseif x=20 then set x=2;
    -> else set x=3;
    -> end if;
    -> return x;
    -> end//
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select exam_if(77);
+-------------+
| exam_if(77) |
+-------------+
|           3 |
+-------------+
1 row in set (0.00 sec)
```

* case语句

#### 句式

```
case [value]
...
when [value] then [methods];
when [value] then [methods];
...
else [methods];
end case;
```

#### 实例

```
mysql> delimiter //
mysql> create function exam_case(x int)
    -> returns int
    -> begin
    -> case x
    -> when 10 then set x=1;
    -> when 20 then set x=2;
    -> else set x=3;
    -> end case;
    -> return x;
    -> end //
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select exam_case(10)
    -> ;
+---------------+
| exam_case(10) |
+---------------+
|             1 |
+---------------+
1 row in set (0.00 sec)
```

```
mysql> create function casetwo3(i int) returns int     ->begin 
    ->case 
    ->when i=7 then return 1; 
    ->when i=14 then return 2; 
    ->else return -1; 
    ->end case; 
    ->end//
mysql> select casetwo3(7)//
+-------------+
| casetwo3(7) |
+-------------+
|           1 |
+-------------+
1 row in set (0.00 sec)
```

#### 条件判断函数

* if()函数

#### 句式

```
if(condition,v1,v2)

当condition的值为true,函数返回v1的值，否则返回v2的值
```

#### 实例

```
mysql> select student_num, course_num,score,if(score>90,'pass','bye') from grade;
+-------------+------------+-------+---------------------------+
| student_num | course_num | score | if(score>90,'pass','bye') |
+-------------+------------+-------+---------------------------+
|           1 |          2 |    98 | pass                      |
|           3 |          1 |    99 | pass                      |
|           2 |          3 |   100 | pass                      |
|           4 |          1 |    87 | bye                       |
|           1 |          9 |    80 | bye                       |
|           1 |          8 |    90 | bye                       |
|           3 |          4 |    96 | pass                      |
|           2 |          5 |    87 | bye                       |
|           3 |          3 |    80 | bye                       |
|           1 |          7 |    95 | pass                      |
|           1 |          1 |    98 | pass                      |
|           3 |          5 |    94 | pass                      |
|           2 |          3 |    93 | pass                      |
|           4 |          7 |    83 | bye                       |
|           1 |         11 |    88 | bye                       |
|           4 |          6 |    91 | pass                      |
|           3 |          4 |    90 | bye                       |
|           4 |          3 |    78 | bye                       |
|           2 |          1 |    80 | bye                       |
+-------------+------------+-------+---------------------------+
19 rows in set (0.00 sec)
```

* ifnull()函数

#### 句式

```
ifnull(v1,v2)
如果v1的值为null,则该函数返回v2的值；否则返回v1的值。
```

#### 实例

* case函数

#### 句式

```
case 表达式1
when value1 then result1
when value2 then result2
else result3
end
```

```
case 
when 表达式1 then result1
when 表达式2 then result2
else result3
end
```

#### 实例

```
mysql> select student_num,course_num,score,(case when score>90 then 'pass' else 'bye' end) as result from grade;
+-------------+------------+-------+--------+
| student_num | course_num | score | result |
+-------------+------------+-------+--------+
|           1 |          2 |    98 | pass   |
|           3 |          1 |    99 | pass   |
|           2 |          3 |   100 | pass   |
|           4 |          1 |    87 | bye    |
|           1 |          9 |    80 | bye    |
|           1 |          8 |    90 | bye    |
|           3 |          4 |    96 | pass   |
|           2 |          5 |    87 | bye    |
|           3 |          3 |    80 | bye    |
|           1 |          7 |    95 | pass   |
|           1 |          1 |    98 | pass   |
|           3 |          5 |    94 | pass   |
|           2 |          3 |    93 | pass   |
|           4 |          7 |    83 | bye    |
|           1 |         11 |    88 | bye    |
|           4 |          6 |    91 | pass   |
|           3 |          4 |    90 | bye    |
|           4 |          3 |    78 | bye    |
|           2 |          1 |    80 | bye    |
+-------------+------------+-------+--------+
19 rows in set (0.00 sec)
```

### 循环语句

* while循环语句

#### 句式

```
while condition do
...
end while;
```

当满足condition时，则执行循环体，否则跳出循环

#### 实例——求1到100项的和

```
mysql> delimiter //
mysql>  create function score_num(n int) returns int
    -> begin
    ->  declare sum int default 0;
    -> declare m int default 1;
    -> while m<=n do 
    -> set sum=sum+m;
    -> set m=m+1;
    ->  end while;
    -> return sum;
    ->  end//
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter ;
mysql> select score_num(100);
+----------------+
| score_num(100) |
+----------------+
|           5050 |
+----------------+
1 row in set (0.00 sec)
```

* loop循环语句

#### 语句

```
label:loop
需要循环操作的语句;
if 条件1 then   ##跳出loop循环的条件判断
leave label;
end if;
end loop;
```

#### 实例

```
mysql> delimiter //
mysql> create function loop_sum(n int) returns int
    -> begin
    -> declare sum int default 0;
    ->  declare m int default 1;
    -> loop_label:loop
    -> set sum=sum+m;
    -> set m=m+1;
    -> if m>n then 
    -> leave loop_label;
    -> end if;
    -> end loop;
    -> return sum;
    -> end //
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select loop_sum(100);
+---------------+
| loop_sum(100) |
+---------------+
|          5050 |
+---------------+
1 row in set (0.00 sec)
```

#### 运用leave label语句来结束循环

#### 运用iterate label语句来结束本次循环操作

定义函数，应用while语句和iterate语句求1-100的偶数之和

```
mysql>  create function iterate_sum(n int) returns int
    -> begin
    -> declare sum char(20) default 0;
    -> declare s int default 0;
    -> add_sum:while true do  ##这边的add_sum是这个循环的记号
    -> set s=s+1;
    -> if(s%2=0) then 
    -> set sum=sum+s;
    ->  else 
    -> iterate add_sum;  ##跳过当前这个循环操作继续下一次循环
    ->  end if;
    -> if(s=n) then 
    -> leave add_sum;  ##跳出整个while循环
    ->  end if;
    -> end while add_sum;
    ->  return sum;
    -> end;
    -> //
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select iterate_sum(100)
    -> ;
+------------------+
| iterate_sum(100) |
+------------------+
|             2550 |
+------------------+
1 row in set (0.01 sec)
```

* repeat循环语句

##### 语句

```
repeat
需要重复执行的语句
until [循环终止的条件]
end repeat
```

##### 实例

```
mysql> delimiter //
mysql> create function exam_repeat(i int) returns int
    -> begin
    -> declare sum int default 0;
    -> declare j int default 1;
    -> repeat
    -> set sum=sum+j;
    -> set j=j+1;
    -> until j>i
    -> end repeat;
    -> return sum;
    -> end //
mysql> select exam_repeat(50)//
+-----------------+
| exam_repeat(50) |
+-----------------+
|            1275 |
+-----------------+
1 row in set (0.00 sec)
```

## 存储过程、游标和触发器

### 存储过程

是一组完成特定功能的Mysql语句的集合，即将一些固定的操作集中起来由Mysql服务器来完成，应用程序只需调用它就可以实现某个特定的任务。存储过程是可以通过用户、其它存储过程或触发器来调用执行的。

#### 创建存储过程

```
mysql> create procedure proc_stu() 
     ->reads sql data 
     ->begin 
     ->select student_num,student_name,student_tel ->from student 
     ->where student_tel like '178%' 
     ->order by student_num; 
     ->end//
```

```
mysql> delimiter ;
```

#### 调用存储过程，调用使用call命令，其中若没有参数，可以直接用call调用存储过程名称.

```
mysql> call proc_stu;
+-------------+--------------+-------------+
| student_num | student_name | student_tel |
+-------------+--------------+-------------+
|           1 | 于晗但       | 17857312377 |
|           3 | 我热饭       | 17857312375 |
+-------------+--------------+-------------+
2 rows in set (0.01 sec)
```

##### 带输入参数存储过程的创建

```
mysql> create procedure select_score(in student_num char(11),course_num char(20))
    -> begin
    -> select *from grade
    -> where grade.student_num=student_num and grade.course_num=course_num;
    -> end//
Query OK, 0 rows affected (0.00 sec)
```

```
mysql> call select_score(1,9)//
+-----------+-------------+------------+-------+------------+
| grade_num | student_num | course_num | score | finalscore |
+-----------+-------------+------------+-------+------------+
|         5 |           1 |          9 |    80 | 86         |
+-----------+-------------+------------+-------+------------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)
```

##### 带输出参数存储过程的创建

```
mysql> create procedure stu_score(in student_num char(20),out count_num int)
    ->  begin
    -> select count(*) into count_num from grade 
    -> where grade.student_num=student_num;
    -> end //
Query OK, 0 rows affected (0.00 sec)
```

调用带输出参数存储过程， 运用@参数名

```
mysql> call stu_score('2',@count_num)//
Query OK, 1 row affected (0.01 sec)

mysql> select @count_num//
+------------+
| @count_num |
+------------+
|          4 |
+------------+
1 row in set (0.00 sec)
```

#### 存储过程与自定义函数的区别

* 存储过程实现的过程要复杂一些,而函数的针对性较强;

- ==存储过程可以有多个返回值,而自定义函数只有一个返回值;并且必须指定返回值为字符串、数值两个数据类型==
- 存储过程一般独立的来执行,而函数往往是作为其他SQL语句的一部分来使用;
- 函数可以直接嵌入到sql语句中；存储过程一般需要单独使用call关键词来调用执行

### 游标(Cursor)

是一种实现对select结果集中的数据进行访问和处理的机制，允许用户访问单独的数据行。一般==通过存储过程来实现游标的操作==


- 触发器(Trigger)

是一种特殊的存储过程。触发器通常在特定的表上定义，当该表的相应事件发生时自动执行，用于实现强制业务规划和数据完整性等。

触发器可以分为insert,update,delete三类，每一类根据执行对先后顺序又可分为before,after触发器。

> 触发器的优点
>
> 1.  触发器自动执行，在表的数据做了任何修改之后立即激活
> 2.  触发器可以通过数据库中的相关表进行层叠更改，更加安全合理
> 3.  触发器可以前置限制，这些限制比用check约束所定义的更复杂，但它可以引用其它表中的列

> 触发器的语法格式

```
create trigger trigger_name trigger_time trigger_event
on table_name for each row trigger_statement;
//table_name引用的一定是永久性表，而不能是临时创建的表或者视图
//trigger_time可以是before或after,用来指明触发程序是在激活它之前或之后触发
//trigger_event指明了激活触发程序的语句的类型，可以是insert、update、delete(replace)，不支持在同一表内同时存在两个有相同激活触发程序的类型
```

> 触发程序中使用old关键词与new关键词
>
> 1.  当向表中插入新记录时，在触发程序中可以利用new关键词访问新记录，当需要访问新记录的某个字段值时，可以使用'new.字段名'的方式访问
> 2.  当从表中删除旧记录时，在触发程序中可以利用old关键词访问旧记录，当需要访问旧记录的某个字段值时，可以使用'old.字段名'的方式访问
> 3.  old记录是只读的，只能引用，不能更改
> 4.  对于insert语句，只有new是合法的；对于delete语句，只有old才是合法的;对于update语句可以与new或old同时使用

- 事件(Event)(也称临时的触发器)

是基于特定时刻或时间周期触发来执行某些任务，而触发器是基于对表进行操作产生的事件触发的

> 事件的创建

```
create event event_name
on schedule [具体在什么时候执行]
do
[具体需要在该事件中操作的内容，若有多个语句则用begin...end包起来]
```

> 创建在指定区间周期性发生的事件

```
create event event_name
on schedule  [具体在什么时候执行]
do
insert into table_name values(current_timestamp);
```

exist:存在一个true就返回，若全为false则不返回
not exist：存在一个false就返回，若全为true则不返回

> 声明游标

语法：

declare cursor_name cursor for select_statement;

> 打开游标

语法：

open cursor_name;

> 从游标中提取数据

语法：

fetch cursor_name into var1,var2,...;

**注意**

1. 变量名(var1,var2...)的个数必须与声明游标时使用的select语句结果集中的字段个数保持一致
2. fetch语句的执行顺序：第1次执行fetch语句，从结果集中提取第1条记录，再次执行，提取第2条。。。以此类推
3. 也正是因为fetch语句每次只从结果集中提取一条记录，因此需要循环语句的配合。

```
fetch_Loop:LOOP
fetch cursor_name into var1,var2,...;
end LOOP;
//其中需要设置循环退出条件，退出循环的语句为
leave fetch_Loop;
//并且需要通过一个Error handler的声明来进行判断，并且游标错误处理程序应该放在声明游标语句之后。
declare continue handler for no found [定义处理程序]
```

> 关闭游标

语法

close cursor_name;

**在存储过程中对游标对使用实际例子**

```
mysql> create procedure proc_cursor()
    -> begin
    -> declare v_tno varchar(6) default '';
    -> declare v_tname varchar(8) default '';
    -> declare teach_cursor cursor
    -> for select student_id,student_name from student;
    -> declare continue handler for not found set @dovar=1;
    -> set @dovar =0;
    -> open teach_cursor;
    -> fetch_Loop:LOOP
    -> fetch teach_cursor into v_tno,v_tname;
    -> if @dovar =1 then
    -> leave fetch_Loop;
    -> else
    -> select v_tno,v_tname;
    -> end if;
    -> end LOOP fetch_Loop;
    -> close teach_cursor;
    -> select @dovar;
    -> end ;//
```

```
mysql> delimiter ;
mysql> call proc_cursor;
+-------+-----------+
| v_tno | v_tname   |
+-------+-----------+
| 1     | 于晗但    |
+-------+-----------+
1 row in set (0.00 sec)

+-------+-----------+
| v_tno | v_tname   |
+-------+-----------+
| 2     | 与哈维    |
+-------+-----------+
1 row in set (0.00 sec)

+-------+-----------+
| v_tno | v_tname   |
+-------+-----------+
| 3     | 我热饭    |
+-------+-----------+
1 row in set (0.00 sec)

+--------+
| @dovar |
+--------+
|      1 |
+--------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)
```


## 索引

表的存储由两部分组成，一部分是表的数据页面，另一部分是索引页面。

数据库中的索引形式与图书的目录类似，键值就像目录中的标题，指针相当于页码。

### 创建索引

- 创建表时附带创建索引
- 通过修改表来创建索引
- 使用alter table语句来创建索引